{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let chain = this.bytes.drop(1).take(1)
let defaultRestAddressStr = match(chain) {
  case base16'57' => "3PQCuvFbvh4LkPUnrnU1z3jnbA1p9m3WNhv"
  case base16'54' => "3MumkGGztCKAXpWDqxkddofqXSUbqQkvSJy"
  case _ => throw("Unknown chain")
}

let SEP = "__"
let LISTSEP = ":"
let DEFAULTQUORUM = 500_000 # 0.5 * 10^6 = 50%
let MAXTITLE = 250
let MAXVOTINGTIME = 1_209_600_000 # 2*7*24*60*60*1000ms
let MULT6 = 1_000_000
let DEFAULTFIRSTPROPOSAL = 1
let SSIZE = 25
let MSIZE = 100
let LSIZE = 225
let XLSIZE = 400
let XXLSIZE = 625

# indices to access proposal data fields (static)
let govIdxProposalTxId = 1
let govIdxTitle        = 2
let govIdxCreationTime = 3
let govIdxStart        = 4
let govIdxEnd          = 5
let govIdxQuorum       = 6
let govIdxOptions      = 7

#indices to access dynamic status data
let govStatusIdxIsValid    = 1
let govStatusIdxWinOpt     = 2
let govStatusIdxWinVotes   = 3
let govStatusIdxTotalVotes = 4
let govStatusIdxIsCanceled = 5

func getStringOrFail(address: Address, key: String) = address.getString(key)
    .valueOrErrorMessage(makeString(["mandatory ", address.toString(), ".", key, " is not defined"], ""))
func getIntOrElse(key: String, defaultVal: Int) = this.getInteger(key).valueOrElse(defaultVal)

# data indices from restConfig
let IdxCfgStakingDapp    = 1
let IdxCfgEconomyDapp    = 2
let IdxCfgGovernanceDapp = 3

func keyRestCfg() = "%s__restConfig"
func keyRestAddress() = "%s__restAddr"

func readRestCfgOrFail(rest: Address) = split_4C(rest.getStringOrFail(keyRestCfg()), SEP)
func getContractAddressOrFail(restCfg: List[String], idx: Int) = restCfg[idx].addressFromString()
  .valueOrErrorMessage("Rest cfg doesn't contain address at index " + idx.toString())

# GLOBAL VARIABLES
let restContract = this.getString(keyRestAddress()).valueOrElse(defaultRestAddressStr).addressFromStringValue()
let restCfg = restContract.readRestCfgOrFail()
let stakingContract = restCfg.getContractAddressOrFail(IdxCfgStakingDapp)
let economyContract = restCfg.getContractAddressOrFail(IdxCfgEconomyDapp)

func keyQuorumRequiredPercent() = "%s__quorumRequired"
func keyLastProposalId() = "%s__proposalId"
func keyFirstProposalId() = "%s__firstProposalId"
func keyProposalStatusDataById(proposalId: Int) = "%s%d__proposalStatusData__" + proposalId.toString()
func keyProposalDataById(proposalId: Int) = "%s%d__proposalData__" + proposalId.toString()
func keyProposalVotesByIdAndOption(proposalId: Int, opt: Int) = makeString(["%s%d%d", "votesByOpt", proposalId.toString(), opt.toString()], SEP)
func keyProposalVotesByIdAndUser(proposalId: Int, userAddr: String) = makeString(["%s%d%s", "votesByUser", proposalId.toString(), userAddr], SEP)
func keyProposalChoiceByIdAndUser(proposalId: Int, userAddr: String) = makeString(["%s%d%s", "optionByUser", proposalId.toString(), userAddr], SEP)
func keyUserGwlReleaseTime(userAddr: String) = "%s%s__userGwlReleaseTime__" + userAddr
# stats
func keyNumUniqueVotersByProposalId(proposalId: Int) = "%s%d__numVoters__" + proposalId.toString()
func keyStatsAverUniqueVoters() = "%s%s%s__stats__avg__uniqueVoters" # 6 decimals
func keyStatsAverGwlVoted() = "%s%s%s__stats__avg__gwlVoted" # 6 decimals

# staking contract keys:
func keyResProportions() = "resTypesProportions"
func keyStakedLandsByOwner(ownerAddr: String) = "stakedLandsByOwner_" + ownerAddr

func asAnyList(v: Any) = {
  match v {
    case l: List[Any] => l
    case _ => throw("fail to cast into List[Any]")
  }
}

func asInt(v: Any) = {
  match v {
    case i: Int => i
    case _ => throw("fail to cast into Int")
  }
}

func statusData(isVotingValid: Boolean, winOption: Int, winOptionVotes: Int, totalVotes: Int, canceledByTeam: Boolean) = {
  makeString(["%b%d%d%d%b",
    isVotingValid.toString(),     # 1 true|false
    winOption.toString(),         # 2 Int
    winOptionVotes.toString(),    # 3 Int
    totalVotes.toString(),        # 4 Int
    canceledByTeam.toString()     # 5 true|false
    ], SEP)
}

func proposalData(proposalTxId: String, title: String, proposalTime: Int, votingStartTime: Int, votingEndTime: Int, quorumInGwl: Int, options: String) = {
  makeString_2C(["%s%s%d%d%d%d%s",
    proposalTxId,               # 1
    title,                      # 2
    proposalTime.toString(),    # 3
    votingStartTime.toString(), # 4
    votingEndTime.toString(),   # 5
    quorumInGwl.toString(),   # 6
    options                     # 7 "NO:YES"
    ], SEP)
}

# data indices to access effective gWL array
let IdxEffTotal = 0
let IdxEffUser  = 1

let recLandNum = 0
let recLandSize = 1
let recTerrains = 2
let recContinent = 3

func numPiecesBySize(landSize: String) = {
  match (landSize) {
    case "S" => SSIZE
    case "M" => MSIZE
    case "L" => LSIZE
    case "XL" => XLSIZE
    case "XXL" => XXLSIZE
    case _ => throw("Unknown land size")
  }
}

# get staked land pieces [total, user]
func getVotingPower(userAddrStrOrEmpty: String) = {
  let props = stakingContract.getString(keyResProportions()).valueOrElse("0_0_0_0_0_0").split("_")
  
  func adder(acc: Int, item: String) = acc + item.parseIntValue()
  
  let totalPower = FOLD<6>(props, 0, adder)

  let usersPower = if (userAddrStrOrEmpty == "") then 0 else {
  let landsStr = stakingContract.getString(keyStakedLandsByOwner(userAddrStrOrEmpty))
  let lands = if (landsStr.isDefined()) then split_51C(landsStr.value(), "_") else []

  func oneLand(acc: Int, landAssetId: String) = {
    let asset = assetInfo(landAssetId.fromBase58String()).value()
    let landSize = asset.description.split("_")[recLandSize]
    acc + numPiecesBySize(landSize)
  }
  FOLD<100>(lands, 0, oneLand)
}

  [totalPower, usersPower]
}

# we can't rely on oldUserChoice, newUserChoice and currentWinner only, as some new leader can appear
func calcWinOption(proposalId: Int, optionsList: List[String], isPrevOptional: Boolean, oldChoice: Int|Unit, optionalTotalOld: Int, 
  newChoice: Int, newTotalByNewChoice: Int) = {

  func findBest(acc: (Int, Int), elem: String) = {
    let idx = optionsList.indexOf(elem).value()
    # check if idx is one of (oldChoice, newchoice)
    let val = if (isPrevOptional) then {
      # only check newChoice
      if (idx == newChoice) then newTotalByNewChoice else getIntOrElse(keyProposalVotesByIdAndOption(proposalId, idx), 0)
    } else {
      # check both oldChoice and newChoice
      if (idx == oldChoice.value()) then {
        optionalTotalOld
      } else {
        if (idx == newChoice) then newTotalByNewChoice else getIntOrElse(keyProposalVotesByIdAndOption(proposalId, idx), 0)
      }
    }
    if (acc._2 > val) then acc else (idx, val)
  }
  
  FOLD<10>(optionsList, (0, 0), findBest) # returns tuple (winning index, win votes)
}

# isVotingValid, winOption, winOptionVotes, totalVotes, canceledByTeam
func updateStatusData(isCanceledStr: String, isValid: Boolean, newWinOpt: (Int, Int), newTotalVotes: Int) = {
  makeString(["%b%d%d%d%b",
    isValid.toString(),
    newWinOpt._1.toString(), # winning option index
    newWinOpt._2.toString(), # winning option votes
    newTotalVotes.toString(),
    isCanceledStr
  ], SEP)
}

# quorumReqPerc=500000
@Callable(i)
func constructorV1(restAddr: String, quorumReqPerc: Int) = {
  if (i.caller != this) then throw("Permission denied") else
  [StringEntry(keyRestAddress(), restAddr),
  IntegerEntry(keyQuorumRequiredPercent(), quorumReqPerc)]
}

#               2nd time different option              #   first time                                         #   2nd time the same option
# oldTotalOldChoice ; oldUserVotes (oldChoice==0)      # (oldChoice undefined)                                # oldUserVotes, newUserVotes (oldChoice==choice==0)
# oldTotalNewChoice ; newUserVotes (choice==1)         # newUserVotes (choice==1)
# oldTotal = oldTotal0 + oldTotal1 + ...
# newTotalOldChoice = oldTotalOldChoice - oldUserVotes # (don't save newTotalOldChoice)                       # newTotal0 = oldTotal0 - oldUserVotes + newUserVotes
# newTotalnewChoice = oldTotalNewChoice + newUserVotes # newTotalNewChoice = oldTotalNewChoice + newUserVotes # 
# newTotal = oldTotal - oldUserVotes + newUserVotes    # newTotal = oldTotal + newUserVotes                   # newTotal = oldTotal - oldUserVotes + newUserVotes
@Callable(i)
func castVote(proposalId: Int, choice: Int) = {
    let userAddressStr = i.caller.toString()
    let dynamicData = this.getStringOrFail(keyProposalStatusDataById(proposalId)).split(SEP) # isVotingValid, winOption, winOptionVotes, totalVotes, canceledByTeam
    if (dynamicData[govStatusIdxIsCanceled] == "true") then throw("Voting is canceled by team") else
    let propData = split_4C(this.getStringOrFail(keyProposalDataById(proposalId)), SEP)
    let start = propData[govIdxStart].parseIntValue()
    let end = propData[govIdxEnd].parseIntValue()
    let now = lastBlock.timestamp
    if (now < start) then throw("Voting not started yet") else
    if (now >= end) then throw("Voting already finished") else
    let availableOptions = propData[govIdxOptions].split(LISTSEP)
    let numOptions = availableOptions.size()
    if (numOptions <= 1) then throw("Too few choices to vote") else
    if (choice >= numOptions) then throw("Unknown choice! Must be 0.." + (numOptions - 1).toString()) else

    let eff = getVotingPower(userAddressStr)
    let gwlAmt = eff[IdxEffUser]
    if (gwlAmt <= 0) then throw("You need staked lands to vote") else
    let gwlTotal = eff[IdxEffTotal]

    let oldChoice = getInteger(keyProposalChoiceByIdAndUser(proposalId, userAddressStr))
    let oldUserVotes = if (!oldChoice.isDefined()) then 0 
        else getIntOrElse(keyProposalVotesByIdAndUser(proposalId, userAddressStr), 0)

    let oldTotalByOldChoice = if (oldChoice.isDefined())
        then getIntOrElse(keyProposalVotesByIdAndOption(proposalId, oldChoice.value()), 0) # left and right cases
        else 0 # mid case

    let oldTotalByNewChoice = getIntOrElse(keyProposalVotesByIdAndOption(proposalId, choice), 0)
    let oldTotal = dynamicData[govStatusIdxTotalVotes].parseIntValue()

    let newTotalByOldChoice = if (!oldChoice.isDefined()) then 0 # mid case (don't save)
        else (oldTotalByOldChoice - oldUserVotes + if (oldChoice.value() == choice) then gwlAmt else 0) # right case (don't save), left case (save)
        
    let newTotalByNewChoice = if (oldChoice.isDefined() && oldChoice.value() == choice) then newTotalByOldChoice else (oldTotalByNewChoice + gwlAmt)

    let newTotal = oldTotal - oldUserVotes + gwlAmt
    let isQuorumReached = newTotal >= propData[govIdxQuorum].parseIntValue()

    let numVotersByProposalId = getIntOrElse(keyNumUniqueVotersByProposalId(proposalId), 0)
    let oldAverUniqueVoters6 = getIntOrElse(keyStatsAverUniqueVoters(), 0) # 6 decimals
    let numProposals = getIntegerValue(keyLastProposalId()) - getInteger(keyFirstProposalId()).valueOrElse(DEFAULTFIRSTPROPOSAL) + 1
    let uniqueDiff = if (oldUserVotes == 0) then 1 else 0
    let newAverUniqueVoters6 = oldAverUniqueVoters6 + fraction(uniqueDiff, MULT6, numProposals)

    let oldAverGwl = getIntOrElse(keyStatsAverGwlVoted(), 0)
    let newAverGwl = oldAverGwl + (gwlAmt - oldUserVotes) / numProposals

    let isPrevOptional = !oldChoice.isDefined() || oldChoice.value() == choice
    let optionalTotalOld = if (isPrevOptional) then []
        else [IntegerEntry(keyProposalVotesByIdAndOption(proposalId, oldChoice.value()), newTotalByOldChoice)]

    let winOpt = calcWinOption(proposalId, availableOptions, isPrevOptional, oldChoice, newTotalByOldChoice, choice, newTotalByNewChoice)
    let releaseTime = max([end, getIntOrElse(keyUserGwlReleaseTime(userAddressStr), 0)])

    ([  IntegerEntry(keyProposalChoiceByIdAndUser(proposalId, userAddressStr), choice),
        IntegerEntry(keyProposalVotesByIdAndUser(proposalId, userAddressStr), gwlAmt),
        IntegerEntry(keyProposalVotesByIdAndOption(proposalId, choice), newTotalByNewChoice),
        IntegerEntry(keyNumUniqueVotersByProposalId(proposalId), numVotersByProposalId + uniqueDiff),
        IntegerEntry(keyUserGwlReleaseTime(userAddressStr), releaseTime),
        IntegerEntry(keyStatsAverUniqueVoters(), newAverUniqueVoters6),
        IntegerEntry(keyStatsAverGwlVoted(), newAverGwl),
        StringEntry(keyProposalStatusDataById(proposalId), updateStatusData(dynamicData[govStatusIdxIsCanceled], isQuorumReached, winOpt, newTotal)) # isVotingValid, winOption, winOptionVotes, totalVotes, canceledByTeam
    ] ++ optionalTotalOld, unit)
}

@Callable(i)
func initiateVoting(title: String, votingStartTime: Int, votingEndTime: Int, optionsList: List[String]) = {
  if (i.caller != this) then throw("Permission denied") else
  if (i.payments.size() != 0) then throw("governance doesn't require any payments") else
  let proposalTxId = i.transactionId.toBase58String()
  if (title == "") then throw("Title is empty") else
  if (title.size() > MAXTITLE) then throw("Too long title") else
  let proposalTime = lastBlock.timestamp
  if (votingStartTime < proposalTime) then throw("votingStartTime=" + votingStartTime.toString() + " < proposalTime=" + proposalTime.toString()) else
  if (votingEndTime < votingStartTime) then throw("votingEndTime=" + votingEndTime.toString() + " < votingStartTime=" + votingStartTime.toString()) else
  if (votingEndTime - votingStartTime > MAXVOTINGTIME) then throw("Voting period exceeds max: " + (votingEndTime - votingStartTime).toString() + " > " + MAXVOTINGTIME.toString()) else
  if (optionsList.size() <= 1) then throw("Too few choices to vote") else
  let eff = getVotingPower("")
  let gPiecesTotal = eff[IdxEffTotal]

  let quorum = getIntOrElse(keyQuorumRequiredPercent(), DEFAULTQUORUM)
  let quorumInGpieces = fraction(quorum, gPiecesTotal, MULT6)

  let proposalId = getIntOrElse(keyLastProposalId(), 0) + 1
  let optionsStr = makeString(optionsList, LISTSEP) # TODO: check options for length and special chars
  ([
    IntegerEntry(keyLastProposalId(), proposalId),
    StringEntry(keyProposalStatusDataById(proposalId), statusData(false, 0, 0, 0, false)), # isVotingValid, winOption, winOptionVotes, totalVotes, canceledByTeam
    StringEntry(keyProposalDataById(proposalId), 
      proposalData(proposalTxId, title.toBytes().toBase16String(), proposalTime, votingStartTime, votingEndTime, quorumInGpieces, optionsStr))
  ], proposalTxId)
}

@Callable(i)
func cancelVoting(proposalId: Int) = {
    if (i.caller != this) then throw("not authorized") else
    let currentData = this.getStringOrFail(keyProposalStatusDataById(proposalId)) # isVotingValid, winOption, winOptionVotes, totalVotes, canceledByTeam
    let updatedData = currentData.take(currentData.lastIndexOf(SEP).value()) + SEP + "true"

    ([StringEntry(keyProposalStatusDataById(proposalId), updatedData)], unit)
}
