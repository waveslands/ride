{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
{-# IMPORT common.ride,landlib.ride,rpglib.ride,wlglib.ride #-}

let incubatorAddr = match(chain) {
  case base16'57' => "3PEktVux2RhchSN63DsDo4b4mz4QqzKSeDv".addressFromStringValue()
  case base16'54' => this
  case _ => throw("Unknown chain")
}
let breederAddr = match(chain) {
  case base16'57' => "3PDVuU45H7Eh5dmtNbnRNRStGwULA7NY6Hb".addressFromStringValue()
  case base16'54' => this
  case _ => throw("Unknown chain")
}
let turtleIncubatorAddr = match(chain) {
  case base16'57' => "3PE9yT1qVM9hsRkpiV6Y7AKEubafyT5NCuB".addressFromStringValue()
  case base16'54' => this
  case _ => throw("Unknown chain")
}
let turtleBreederAddr = match(chain) {
  case base16'57' => "3P97G4z2qH2pZGPYwWw47pFQu7cpyjR579t".addressFromStringValue()
  case base16'54' => this
  case _ => throw("Unknown chain")
}
let FIVEMINUTESMILLIS = 300_000 # 5*60*1000
let RENAMINGCOST = 5_000_000
let MAXNAMELEN = 50
let InfraUpgradeCostSUsdt = 10_000_000 # $10 (was $40) * L need to upgrade S land from (L-1) to L level
let EXPMATERIALS = match(chain) {
  case base16'57' => 2522_8952_7462 # 2522.89527462 (was 1576.79960139) materials need to send expedition; EXPUSDT * 0.8 / (2 * RESOURCEPRICEMIN)
  case base16'54' => 25_2289_5274 # /100 for testnet
  case _ => throw("Unknown chain")
}
let EXPUSDT = match(chain) {
  case base16'57' => 250_000_000
  case base16'54' => 250_000_000
  case _ => throw("Unknown chain")
}
let ROBO_DUCK_USDT = 100_000 # $0.10
let S_COST_ACRES = 25_0000_0000
let FIVEX = toBigInt(5)
let TWENTYX = toBigInt(20)
let TWENTY2X = toBigInt(20*20)
let TWENTY3X = toBigInt(20*20*20)
let TWENTY4X = toBigInt(20*20*20*20)
let TWENTY5X = toBigInt(20*20*20*20*20)
let PRESALENUMLANDS = 500

func keyNextFreeLandNum() = "nextLandNum"
# land specific keys (to be deleted after merge)
func keyLandCustomNameToAssetId(name: String) = "lcn_" + name
func keyLandToAssetId(landNum: String) = "la_" + landNum
func keyInfraLevelByAssetIdAndOwner(assetId: String, ownerAddr: String) = "ilao_" + assetId + "_" + ownerAddr
func keyLandNumToOwner(landNum: String) = "lo_" + landNum

func keyDuckCustomNameToAssetId(name: String) = "duckByCustomName_" + name
func keyCustomNameToAddress(name: String) = "accountByCustomName_" + name
func keyOldies() = "oldiesList"
func keyNextRoboDuck() = "nextRoboDuck"

# let testDucks = ["DUCK-DDDDDDDD-GG", "DUCK-BBBABAAA-HG", "DUCK-CCCBCBCC-IG", "DUCK-DDCADBAA-KG", 
#   "DUCK-EEEDECBA-LG", "DUCK-FFEDECBA-MG", "DUCK-GGFDECBA-NG", "DUCK-HGFHEHHH-NG", 
#   "DUCK-IGFDECBA-OG", "DUCK-KIGEFDCB-OG", "DUCK-LKIFGEDC-OG", "DUCK-ACACACAC-IG"
# ]

let claimModeWh = 0 # claim to warehouse only
let claimModeDuck = 1 # claim to duck's backpack only
let claimModeWhThenDuck = 2 # claim to warehouse until filled, then to duck's backpack

# flightLog groups
let flHealth = 0
let flMission = 1
let flObstacles = 2
let flWinds = 3
let flPath = 4
let flTimestamp = 5
let flBonus = 6
let flProdsUsed = 7

# robLog group0
let rlHealth = 0
let rlProdsUsed = 1

# robLog group1
let rlType = 0
let rlLastTx = 2
let rlTimestamp = 3

func nftName(landNum: String, landSize: String) = LANDPREFIX + landNum + landSize

func toVolume(amount: Int, pkgSize: Int) = {
  let pkgs = if (amount >= 0) then (amount + pkgSize - 1) / pkgSize else -((-amount + pkgSize - 1) / pkgSize)
  pkgs * MULT8
}

# Given: total = amount to distribute; [w0, w1, w2, w3, w4, w5] = weights array
# Find normalizing coeff. N, such as: N * (w0 + w1 + w2 + w3 + w4 + w5) = total
# return array: [N * w0, N * w1, N * w2, N * w3, N * w4, N * w5]
func distributeByWeights(total: Int, weights: List[Int]) = {
  let sum = weights[0] + weights[1] + weights[2] + weights[3] + weights[4] + weights[5]
  if (sum <= 0) then throw("Zero weights sum") else
  let norm6 = fraction(total, MULT6, sum)

  func normalizer(acc: List[Int], elem: Int) = {
    acc :+ fraction(elem, norm6, MULT6)
  }
  (FOLD<6>(weights, [], normalizer))
}

# Given: total = amount of materials to distribute by types
# return needed materials: [N * r0, N * r1, N * r2, N * r3, N * r4, N * r5]
func getNeededMaterials(total: Int) = {
  let props = getString(keyResProportions()).value().split("_")
  if (props.size() != NUMRES) then throw("Wrong proportions data") else
  let r = [props[0].parseIntValue(), props[1].parseIntValue(), props[2].parseIntValue(),
    props[3].parseIntValue(), props[4].parseIntValue(), props[5].parseIntValue()]
  distributeByWeights(total, r)
}

func subtractMaterials(shouldUseMat: Boolean, has: List[String], totalNeed: Int) = {
  let need = getNeededMaterials(totalNeed)
  func subtractor(acc: List[String], idx: Int) = {
    let result = has[idx].parseIntValue() - need[idx]
    if (result < 0) then throw("Not enough material idx=" + idx.toString() + 
      ", you have " + has[idx] + ", but need " + need[idx].toString()) else
    acc :+ result.toString()
  }
  if (shouldUseMat) then (FOLD<6>(ITER6, [], subtractor)) else has
}

# oldEq: 01:3,02:3;01:3,_01:3,02:3;01:3,_;_;_;_;
# pUsed: 05,1_12,2 (product index, used quantity)
func subtractEquipment(oldEq: String, pUsed: String) = {
  if (pUsed == "") then (oldEq, false, false) else

  func subUsed(acc: (String, Boolean, Boolean), idxAmt: String) = {
    let parts = idxAmt.split(",") # next used item
    if (parts.size() != 2) then throw("Incorrect format, should be index,amount") else
    let idx = parts[0].parseIntValue() # used productIdx
    if (idx < 0 || idx >= productionMatrix.size()) then throw("Unknown product idx") else
    let amt = parts[1].parseIntValue() # used amount
    # find idx: substring in oldEq
    let eqParts = acc._1.split(parts[0] + ":")
    if (eqParts.size() != 2) then throw("You don't have " + prodTypes[idx] + " equipped") else
    let tmp = eqParts[1]
    let numLen = if (tmp.drop(1).take(1).isDigit()) then 2 else 1
    let curr = tmp.take(numLen).parseIntValue()
    let tail = tmp.drop(numLen)
    let newAmt = if (curr >= amt) then curr - amt else throw("You equipped " + curr.toString() + " of " + prodTypes[idx] + ", but tried to use " + amt.toString())
    (
      eqParts[0] + parts[0] + ":" + newAmt.toString() + tail, 
      acc._2 || (idx >= 6 && idx <= 8 && newAmt == 0),
      acc._3 || (idx >= 3 && idx <= 5 && amt > 0)
    )
  }
  FOLD<10>(pUsed.split("_"), (oldEq, false, false), subUsed)
}

func prodStrToBytes(prodStr: String) = {
  let pList = if (prodStr == "") then [] else prodStr.split_4C("_")

  func toBV(acc: ByteVector, recipe: String) = {
    let j = acc.size() / 8
    let curr = if (j < pList.size()) then pList[j].parseIntValue() else 0
    acc + curr.toBytes()
  }
  FOLD<50>(productionMatrix, base16'', toBV)
}

func bytesToProdStr(bv: ByteVector) = {
  func fromBV(acc: List[String], recipe: String) = {
    let j = acc.size()
    let b = bv.drop(8 * j).take(8)
    acc :+ b.toInt().toString()
  }
  makeString_2C(FOLD<50>(productionMatrix, [], fromBV), "_")
}

func checkStatRequirements(duckStats: List[Int], reqs: List[String]) = {
  func check(acc: Boolean, j: Int) = {
    let buff = if (duckStats.size() > 7 + j) then duckStats[7 + j] else 0
    if (duckStats[j] + buff < reqs[j].parseIntValue()) then throw("Requirement not satisfied: " + requirements[j]) else
    true
  }
  FOLD<7>([0, 1, 2, 3, 4, 5, 6], false, check)
}

# put/remove items to land fortification
func placeProdB(idxCnt: String, pList: ByteVector, isPositive: Boolean, duckStats: List[Int], occupied: Int, free: Int) = {
  let parts = idxCnt.split(":")
  if (parts.size() != 2) then throw("Incorrect format, should be index:amount") else
  if (!isPositive && parts[0].size() != 2) then throw("Product idx should be 2 digits, zero padded") else
  let productIdx = parts[0].parseIntValue()
  let count = parts[1].parseIntValue()
  if (!fortAllowedProds.containsElement(productIdx)) then throw("Product '" + prodTypes[productIdx] + "' cannot be used for land defense") else
  if (count < 0) then throw("Count can't be negative") else
  if (count > MAXPRODINSLOT) then throw("Can't put more than " + MAXPRODINSLOT.toString() + " of " + prodTypes[productIdx]) else
  if (count == 0) then (pList, occupied, free) else

  let head = pList.take(8 * productIdx)
  let curr = pList.drop(8 * productIdx).take(8).toInt()
  let tail = pList.drop(8 * (productIdx + 1))

  let recipe = productionMatrix[productIdx].split("_")
  if (!isPositive && curr < count) then throw("You have " + curr.toString() + " of " + prodTypes[productIdx] + ", but tried to use " + count.toString()) else
  let newAmt = if (!isPositive && checkStatRequirements(duckStats, recipe[rIdxRequirements].split(","))) 
    then curr - count # put on => take from wh
    else curr + count # take off => add to wh
  
  let deltaVol = toVolume(newAmt, PRODUCTPKGSIZE) - toVolume(curr, PRODUCTPKGSIZE)
  (head + toBytes(newAmt) + tail, occupied + deltaVol, free - deltaVol)
}

# wear/remove items to duck slot
func addProdB(idxCnt: String, pList: ByteVector, isPositive: Boolean, segment: Int, mainAux: Int, slot: Int, duckStats: List[Int]) = {
  let parts = idxCnt.split(":")
  if (parts.size() != 2) then throw("Incorrect format, should be index:amount") else
  if (!isPositive && parts[0].size() != 2) then throw("Product idx should be 2 digits, zero padded") else
  let productIdx = parts[0].parseIntValue()
  let count = parts[1].parseIntValue()
  if (productIdx < 0 || productIdx >= productionMatrix.size()) then throw("Unknown product idx") else
  if (count < 0) then throw("Count can't be negative") else
  if (count > MAXPRODINSLOT) then throw("Can't put more than " + MAXPRODINSLOT.toString() + " of " + prodTypes[productIdx]) else
  if (count == 0) then (pList, false) else

  let head = pList.take(8 * productIdx)
  let curr = pList.drop(8 * productIdx).take(8).toInt()
  let tail = pList.drop(8 * (productIdx + 1))

  let recipe = productionMatrix[productIdx].split("_")
  if (!isPositive && curr < count) then throw("You have " + curr.toString() + " of " + prodTypes[productIdx] + ", but tried to use " + count.toString()) else
  let isBigItem = if (!isPositive && checkStatRequirements(duckStats, recipe[rIdxRequirements].split(","))) then {
    let compat = recipe[rIdxSlots]
    if (compat == "") then throw("Item cannot be equipped") else
    let c = compat.parseIntValue()
    let cSeg = c / 100
    if (segment != cSeg) then throw("Segment incompatible") else
    let cMainAux = (c % 100) / 10
    if (mainAux != cMainAux) then throw("Slot incompatible") else
    let cNumSlots = c % 10
    if (slot != 0 && cNumSlots > 1) then throw("Big items should occupy slot 0") else
    cNumSlots > 1
  } else false

  (head + toBytes(curr + (if (isPositive) then count else -count)) + tail, isBigItem)
}

func slotsGroupB(g: String, bpIn: ByteVector, isPositive: Boolean, segment: Int, mainAux: Int, stats: List[Int]) = {
  if (g != "") then {
    let slots = g.split(",")
    if (slots.size() > MAXSLOTS) then throw("Wrong slots format") else
    let s0 = slots[0]
    let s1 = if (slots.size() > 1) then slots[1] else ""
    if (s0 == "" && s1 == "") then bpIn else {
      let tmpS0 = if (s0 != "") then addProdB(s0, bpIn, isPositive, segment, mainAux, 0, stats) else (bpIn, false)
      if (s1 != "") then {
        if (tmpS0._2) then throw("Big item already occupies slot") else
        (addProdB(s1, tmpS0._1, isPositive, segment, mainAux, 1, stats))._1
      } else tmpS0._1
    }
  } else bpIn
}

# 01:3,02:3;01:3,_01:3,02:3;01:3,_;_;_;_;
# equipment.split("_") => list of 6 segments ['backpack', 'back', 'belt', 'hands', 'head', 'body']
# segment.split(";") => list of [mainSlots, auxSlots]
# {mainSlots|auxSlots}.split(",") => [slot0(, slot1)]
# slot.split(":") => [productIdx, count]
# pBytes - products in backpack as byte vector
# isPositive = true for takeOff, false for putOn (backpack amounts increase or decrease)
func dressB(segList: List[String], pBytes: ByteVector, isPositive: Boolean, stats: List[Int]) = {

  func segment(acc: (Int, ByteVector), seg: String) = {
    let j = acc._1 # segment idx
    let mainAux = seg.split(";")
    if (mainAux.size() != NUMMAINAUX) then throw("Wrong segment format") else
    let m = mainAux[0]
    let a = mainAux[1]
    if (m == "" && a == "") then (j + 1, acc._2) else
    let tmpM = slotsGroupB(m, acc._2, isPositive, j, 0, stats)
    (j + 1, slotsGroupB(a, tmpM, isPositive, j, 1, stats))
  }
  (FOLD<6>(segList, (0, pBytes), segment))._2
}

func canWearCurrentEquipment(duckAssetId: String) = {
  let eqKey = keyDuckEquipment(duckAssetId)
  let currEq = getString(eqKey).valueOrElse(",;,_,;,_,;,_,;,_,;,_,;,").split("_")
  let EMPTY_PROD50 = base64'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=='
  let tempProdB = dressB(currEq, EMPTY_PROD50, true, []) # take off
  let segBpAux = currEq[segBackpack].split(";")[1] # backpack aux slots - "" or *,*
  let buffEffect = if (segBpAux == "") then 0 else {
    let aux0 = segBpAux.split(",")[0]
    if (aux0 == "") then 0 else {
      let idxCnt = aux0.split(":")
      let idx = idxCnt[0]
      let cnt = idxCnt[1]
      if ((idx == "06" || idx == "07" || idx == "08") && cnt != "" && cnt.parseIntValue() > 0) then 
        productionMatrix[idx.parseIntValue()].split("_")[rIdxEffect].parseIntValue() else 0
    }
  }
  let stats = getDuckStats(this, duckAssetId, buffEffect, true) # Strength, Accuracy, Intellect, Endurance, Dexterity, Level, Health, StrengthBuff, AccuracyBuff, IntellectBuff, EnduranceBuff, DexterityBuff
  let newProdB = dressB(currEq, tempProdB, false, stats) # virtually put on (and check requirements)
  newProdB == newProdB
}

# add continentPropList
func updateProportionsInternal(propList: List[String], terrainCounts: List[Int], landSizeIndex: Int, sign: Int) = {
  if (propList.size() != NUMRES) then throw("Wrong proportions data") else
  func updater(acc: List[String], i: Int) = {
    let result = propList[i].parseIntValue() + sign * terrainCounts[i] * landSizeIndex
    if (result < 0) then throw("Panic! Pieces of type=" + i.toString() + ", sign=" + sign.toString() 
      + ", terrainCounts[i]=" + terrainCounts[i].toString() + ", landSizeIndex=" + landSizeIndex.toString()) else
    acc :+ result.toString()
  }
  FOLD<6>(ITER6, [], updater)
}

func updateProportions(terrainCounts: List[Int], landSizeIndex: Int, sign: Int) = {
  let propList = getString(keyResProportions()).valueOrElse("0_0_0_0_0_0").split("_")
  updateProportionsInternal(propList, terrainCounts, landSizeIndex, sign).makeString("_")
}

#                               A   B  C  D  E  F
# BFBBFBDFBBEDDBDFEEBDBDBFF => [0, 10, 0, 6, 3, 6]
func countTerrains(terrains: String) = {
  [terrains.split("A").size() - 1,
    terrains.split("B").size() - 1,
    terrains.split("C").size() - 1,
    terrains.split("D").size() - 1,
    terrains.split("E").size() - 1,
    terrains.split("F").size() - 1]
}

func addRes(currentRes: List[String], terrainCounts: List[Int], deltaTime: Int, landSizeIndex: Int, dailyByPieceWithBonuses: Int) = {

  func adder(acc: List[String], i: Int) = {
    let resOfType = fraction(deltaTime, dailyByPieceWithBonuses, DAYMILLIS) * terrainCounts[i] * landSizeIndex
    acc :+ (currentRes[i].parseIntValue() + resOfType).toString()
  }
  let r = FOLD<6>(ITER6, [], adder)
  r.makeString("_")
}

func virtClaimAddRes(currentRes: List[String], terrainCounts: List[Int], deltaTime: Int, landSizeIndex: Int, dailyByPieceWithBonuses: Int) = {

  func adder(acc: (List[Int], Int), i: Int) = {
    let resOfType = fraction(deltaTime, dailyByPieceWithBonuses, DAYMILLIS) * terrainCounts[i] * landSizeIndex
    let totalResType = currentRes[i].parseIntValue() + resOfType
    (acc._1 :+ totalResType, acc._2 + totalResType)
  }
  FOLD<6>(ITER6, ([], 0), adder)
}

func virtClaim(terrainCounts: List[Int], deltaTime: Int, landSizeIndex: Int, dailyByPieceWithBonuses: Int) = {

  func adder(acc: (List[Int], Int), terrainCount: Int) = {
    let resOfType = fraction(deltaTime, dailyByPieceWithBonuses, DAYMILLIS) * terrainCount * landSizeIndex
    (acc._1 :+ resOfType, acc._2 + resOfType)
  }
  FOLD<6>(terrainCounts, ([], 0), adder)
}

# fill warehouse first, then backpack
func distributeRes(currentWhRes: List[String], currentPackRes: List[String], resToClaim: (List[Int], Int), whSpaceLeft: Int) = {
  let resListToClaim = resToClaim._1
  let resAmToClaim = resToClaim._2
  if (resAmToClaim == 0) then (currentWhRes.makeString("_"), currentPackRes.makeString("_")) else
  if (resAmToClaim <= whSpaceLeft) then {
    func addLists(acc: List[String], i: Int) = {
      acc :+ (currentWhRes[i].parseIntValue() + resListToClaim[i]).toString()
    }
    let r = FOLD<6>(ITER6, [], addLists)
    (r.makeString("_"), currentPackRes.makeString("_"))
  } else { # put only whSpaceLeft/resAmToClaim part to the warehouse
    func addPartLists(acc: (List[String], List[String]), i: Int) = {
      let whPart = fraction(resListToClaim[i], whSpaceLeft, resAmToClaim)
      (acc._1 :+ (currentWhRes[i].parseIntValue() + whPart).toString(),
      acc._2 :+ (currentPackRes[i].parseIntValue() + resListToClaim[i] - whPart).toString())
    }
    let r = FOLD<6>(ITER6, ([], []), addPartLists)
    (r._1.makeString("_"), r._2.makeString("_"))
  }
}

func abs(x: BigInt) = if (x >= toBigInt(0)) then x else -x

# todo: amplify probablities by current proportions bias
# continent is already randomly generated, so we take its target freqs:
# let targetFreqs = targetFreqByContinent[contIdx]
# let currentFreqs = getCurrTerrains(contIdx)
# ta+tb+tc+td+te+tf = 120 # target
# a+b+c+d+e+f = totalCont # current
# deltaA = a/totalCont - ta/120 # ideally = 0
# LI = landIndex
# generate A+B+C+D+E+F = 25
# Sum ((ai+Ai*LI)/(totalCont + 25*LI) - tai/120)^2 = min
let targetFreqByContinent = [
  [35, 18, 30,  7,  6, 24], #120 Americas
  [29, 18, 29,  7,  8, 29], #120 Europe
  [ 6, 18, 29,  8, 30, 29], #120 Asia
  [ 6, 28,  6, 48, 26,  6], #120 Africa
  [24, 18,  6, 30, 30, 12]  #120 Oceania
]#100,100,100,100,100,100

# todo: add proportions records for each continent
# let propList = getString(keyResProportions()).valueOrElse("0_0_0_0_0_0").split("_")
let freq = [ # frequency of different terrains per continent
  [6, 9, 14, 15, 16],
  [5, 8, 13, 14, 15],
  [1, 4, 9, 10, 15],
  [1, 6, 7, 15, 19],
  [4, 7, 8, 13, 18]
]

func genChar(n: BigInt, freqs: List[Int]) = {
  let rem = (n % TWENTYX).toInt() # 0..19
  let letter = if (rem < freqs[0]) then "A"
    else if (rem < freqs[1]) then "B"
    else if (rem < freqs[2]) then "C"
    else if (rem < freqs[3]) then "D"
    else if (rem < freqs[4]) then "E"
    else "F"
  
  letter
}

func genTerrains(seed: BigInt, continentIdx: Int) = {
  let f = freq[continentIdx]

  func terrainGenerator(acc: (String, BigInt), elem: Int) = {
    (acc._1 + 
      genChar(acc._2, f) + genChar(acc._2 / TWENTYX, f) + genChar(acc._2 / TWENTY2X, f) + genChar(acc._2 / TWENTY3X, f) + genChar(acc._2 / TWENTY4X, f), 
    acc._2 / TWENTY5X)
  }

  let t = FOLD<5>([1, 2, 3, 4, 5], ("", seed / FIVEX), terrainGenerator)
  t._1
}

let PERM25 = [7, 2, 15, 19, 8, 24, 1, 21, 16, 5, 0, 22, 20, 23, 11, 4, 18, 12, 6, 10, 3, 17, 13, 9, 14]
let TCHARS = ["A", "B", "C", "D", "E", "F"]

# aver = 25/6 = 4+ pieces per terrain
# 0 => 0
# 0*landSizeIndex + 1 .. 1*landSizeIndex => 1
# 1*landSizeIndex + 1 .. 2*landSizeIndex => 2
# 2*landSizeIndex + 1 .. 3*landSizeIndex => 3
# 3*landSizeIndex + 1 .. 4*landSizeIndex-1 => 3
# 4*landSizeIndex .. inf => sumTerrains[i] / landSizeIndex
func genTerrainsForMerge(sumTerrains: List[String], landSizeIndex: Int) = {
  # step 1 - find exact numTerrains[i] like sumTerrains[i] / landSizeIndex
  func step1(acc: (List[Int], Int, Int), s: String) = {
    let j = acc._2 # iterating index
    let el = s.parseIntValue()
    let x = if (el == 0) then 0 
      else if (el >= 4 * landSizeIndex) then el / landSizeIndex 
      else if (el > 3 * landSizeIndex) then 3
      else (el - 1) / landSizeIndex + 1
    (acc._1 :+ x, acc._2 + 1, acc._3 + x)
  }
  let t = FOLD<6>(sumTerrains, ([], 0, 0), step1)
  let arr = t._1
  let maxIdx = arr.indexOf(max(arr)).value()
  let delta = t._3 - 25
  # decrease maxIdx-th element of arr by delta
  # todo: replace all this shit with arr.replaceByIndex(maxIdx, arr[maxIdx] - delta), when node team implements replaceByIndex
  func subber(acc: List[String], idx: Int) = {
    let val = if (idx == maxIdx) then arr[idx] - delta else arr[idx]
    let zeroes = if (val == 0) then [] else pow(10, 0, val, 0, 0, DOWN).toString().drop(1).split("")
    let c = TCHARS[idx]

    # generate list of c X val
    func listGen(ac: List[String], ignored: String) =
      ac :+ c
    
    let z = FOLD<25>(zeroes, [], listGen)
    acc ++ z
  }
  let r = FOLD<6>(ITER6, [], subber)

  func permut(acc: String, j: Int) =
    acc + r[j]
  
  FOLD<25>(PERM25, "", permut)
}

# return 4 strings: [level, resListStr, matListStr, prodListStr]
func getBackpack(bpKey: String) = {
  let p = getString(bpKey).valueOrElse("0:0_0_0_0_0_0:0_0_0_0_0_0:").split(":")
  [
    p[bpIdxLevel].parseInt().valueOrElse(0).toString(),
    if (p[bpIdxRes].split("_").size() == NUMRES) then p[bpIdxRes] else "0_0_0_0_0_0",
    if (p[bpIdxMat].split("_").size() == NUMRES) then p[bpIdxMat] else "0_0_0_0_0_0",
    p[bpIdxProd] # "" if no products
  ]
}

# warehouse volume prefix is landIndex_infaLevel
func getWarehouseTotalVolume(volPrefix: String) = {
  let parts = volPrefix.split("_")
  WHMULTIPLIER * (parts[1].parseIntValue() + 1) * parts[0].parseIntValue()
}

func getWarehouseOccupiedVol(currentWh: List[String]) = {
  let goods = currentWh[whIdxProd]

  func sumResMat(acc: Int, item: String) = {
    acc + item.parseIntValue()
  }

  # acc: (productIndex, productsVolume)
  func sumProd(acc: (Int, Int), item: String) = {
    let idx = acc._1
    let pkgs = (item.parseIntValue() + PRODUCTPKGSIZE - 1) / PRODUCTPKGSIZE
    (idx + 1, acc._2 + pkgs * MULT8)
  }
  let whResVol = FOLD<6>(currentWh[whIdxRes].split("_"), 0, sumResMat)
  let whMatVol = FOLD<6>(currentWh[whIdxMat].split("_"), 0, sumResMat)
  let whGoodsVol = if (goods == "") then 0 else (FOLD<50>(split_4C(goods, "_"), (0, 0), sumProd))._2
  whResVol + whMatVol + whGoodsVol
}

# return 5 strings: [volPrefix, resListStr, matListStr, prodListStr, locked_occupied_free_totalVol]
func getWarehouse(whKey: String, landIndex: Int, infraLevel: Int) = {
  let volPrefix = landIndex.toString() + "_" + infraLevel.toString()
  let whTotal = getWarehouseTotalVolume(volPrefix)
  let whStr = getString(whKey).valueOrElse(volPrefix + ":0_0_0_0_0_0:0_0_0_0_0_0::0")
  let wh = split_4C(whStr, ":")
  let whOccupied = getWarehouseOccupiedVol(wh)
  let whLoft = if (wh.size() < 5) then {
    makeString(["0", whOccupied.toString(), toString(whTotal - whOccupied), whTotal.toString()], "_")
  } else {
    let loft = wh[whIdxLOFT].split("_")
    let whLocked = loft[volLocked].parseIntValue()
    let occ = if (loft.size() > 1) then loft[volOccupied].parseIntValue() else whOccupied
    makeString([whLocked.toString(), occ.toString(), toString(whTotal - whLocked - occ), whTotal.toString()], "_")
  }
  [
    wh[whIdxLevels],
    if (wh[whIdxRes].split("_").size() == NUMRES) then wh[whIdxRes] else "0_0_0_0_0_0",
    if (wh[whIdxMat].split("_").size() == NUMRES) then wh[whIdxMat] else "0_0_0_0_0_0",
    wh[whIdxProd], # "" if no products
    whLoft # locked_occupied_free_total
  ]
}

func getWarehouseSpaceLeft(currentWh: List[String]) = {
  let occupiedVol = getWarehouseOccupiedVol(currentWh)
  let currWhLockedVol = currentWh[whIdxLOFT].split("_")[volLocked].parseIntValue()

  getWarehouseTotalVolume(currentWh[whIdxLevels]) - occupiedVol - currWhLockedVol
}

# zero amount means ignore position
# '-' means direction from warehouse to backpack, '+' - from backpack to warehouse
# cargoParts: list of 3 strings: resListStr, matListStr, prodListStr
# currentWh: list of 5 strings: [volPrefix, resListStr, matListStr, prodListStr, lockedVol]
# currentPack: list of 4 strings: [level, resListStr, matListStr, prodListStr]
func moveStuff(cargoParts: List[String], currentWh: List[String], currentPack: List[String]) = {
  if (cargoParts.size() != 3) then throw("cargoListStr should contain exactly 2 ':' separators") else
  let resParts = cargoParts[0].split("_")
  let matParts = cargoParts[1].split("_")
  let prodParts = if (cargoParts[2] == "") then [] else cargoParts[2].split_4C("_")
  if (resParts.size() != NUMRES) then throw("All 6 resources should be passed") else
  if (matParts.size() != NUMRES) then throw("All 6 materials should be passed") else
  let whSpaceLeft = getWarehouseSpaceLeft(currentWh)

  let currWhRes = currentWh[whIdxRes].split("_") # resources already in warehouse
  let currWhMat = currentWh[whIdxMat].split("_") # materials already in warehouse
  let currWhProd = if (currentWh[whIdxProd] == "") then [] else currentWh[whIdxProd].split_4C("_") # products already in warehouse

  let currentPackRes = currentPack[bpIdxRes].split("_") # resources already in backpack
  let currentPackMat = currentPack[bpIdxMat].split("_") # materials already in backpack
  let currentPackProd = if (currentPack[bpIdxProd] == "") then [] else currentPack[bpIdxProd].split_4C("_") # products already in backpack

  func mvR(acc: (Int, List[String], List[String], Int), item: String) = {
    let i = acc._1
    let am = item.parseIntValue()
    let whr = currWhRes[i].parseIntValue()
    let bpr = currentPackRes[i].parseIntValue()
    if (am == 0) then {
      (i+1, acc._2 :+ currWhRes[i], acc._3 :+ currentPackRes[i], acc._4)
    } else if (am > 0) then { # move from bp to wh
      if (bpr < am) then throw("Attempt to take " + item + " from backpack, but only " + bpr.toString() + " available") else
      (i+1, acc._2 :+ toString(whr + am), acc._3 :+ toString(bpr - am), acc._4 + am)
    } else { # move from wh to bp
      if (whr < -am) then throw("Attempt to take " + toString(-am) + " from warehouse, but only " + whr.toString() + " available") else
      (i+1, acc._2 :+ toString(whr + am), acc._3 :+ toString(bpr - am), acc._4 + am)
    }
  }
  let r = FOLD<6>(resParts, (0, [], [], 0), mvR)

  func mvM(acc: (Int, List[String], List[String], Int), item: String) = {
    let i = acc._1
    let am = item.parseIntValue()
    let whm = currWhMat[i].parseIntValue()
    let bpm = currentPackMat[i].parseIntValue()
    if (am == 0) then {
      (i+1, acc._2 :+ currWhMat[i], acc._3 :+ currentPackMat[i], acc._4)
    } else if (am > 0) then { # move from bp to wh
      if (bpm < am) then throw("Attempt to take " + item + " from backpack, but only " + bpm.toString() + " available") else
      (i+1, acc._2 :+ toString(whm + am), acc._3 :+ toString(bpm - am), acc._4 + am)
    } else { # move from wh to bp
      if (whm < -am) then throw("Attempt to take " + toString(-am) + " from warehouse, but only " + whm.toString() + " available") else
      (i+1, acc._2 :+ toString(whm + am), acc._3 :+ toString(bpm - am), acc._4 + am)
    }
  }
  let m = FOLD<6>(matParts, (0, [], [], r._4), mvM)

  # acc: counter, whProd, bpProd, volume
  func mvP(acc: (Int, List[String], List[String], Int), item: String) = {
    let i = acc._1
    let am = item.parseIntValue()
    let whp = if (currWhProd.size() > i) then currWhProd[i].parseIntValue() else 0
    let bpp = if (currentPackProd.size() > i) then currentPackProd[i].parseIntValue() else 0
    if (am == 0) then {
      (i+1, acc._2 :+ whp.toString(), acc._3 :+ bpp.toString(), acc._4)
    } else if (am > 0) then { # move from bp to wh
      if (bpp < am) then throw("Attempt to take " + item + " from backpack, but only " + bpp.toString() + " available") else
      let deltaVol = toVolume(whp + am, PRODUCTPKGSIZE) - toVolume(whp, PRODUCTPKGSIZE)
      (i+1, acc._2 :+ toString(whp + am), acc._3 :+ toString(bpp - am), acc._4 + deltaVol)
    } else { # move from wh to bp
      if (whp < -am) then throw("Attempt to take " + toString(-am) + " from warehouse, but only " + whp.toString() + " available") else
      let deltaVol = toVolume(whp + am, PRODUCTPKGSIZE) - toVolume(whp, PRODUCTPKGSIZE)
      (i+1, acc._2 :+ toString(whp + am), acc._3 :+ toString(bpp - am), acc._4 + deltaVol)
    }
  }
  let p = if (prodParts.size() != 0) then (FOLD<50>(prodParts, (0, [], [], m._4), mvP)) else (0, currWhProd, currentPackProd, m._4)
  let volSaldo = p._4 # positive means amount to put in WH
  if (whSpaceLeft < volSaldo) then throw("Attempt to put total " + volSaldo.toString() + " stuff, but only " + whSpaceLeft.toString() + " warehouse space left") else
  # (whRes, whMat, whProd, bpRes, bpMat, bpProd)
  (makeString(r._2, "_"), makeString(m._2, "_"), makeString_2C(p._2, "_"), makeString(r._3, "_"), makeString(m._3, "_"), makeString_2C(p._3, "_"), volSaldo)
}

func applyBonuses(landAssetId: String, pieces: Int) = {
  let infraLevel = getInteger(keyInfraLevelByAssetId(landAssetId)).valueOrElse(0)
  # base * (1 + 0.2*Level + 0.2*(isActive ? artPieces/pieces : 0))
  let artPieces = getInteger(keyLandArtStatusByTypeAndAssetId(ARTPRESALE, landAssetId)).valueOrElse(0)
  let add6 = infraLevel / 6 # 0 for levels 0..5, 1 otherwise
  let add7 = infraLevel / 7 # 0 for levels 0..6, 1 otherwise
  DAILYRESBYPIECE + fraction(DAILYRESBYPIECE, (infraLevel + add6 + 2*add7), 5) + fraction(DAILYRESBYPIECE, artPieces, pieces * 5)
}

func checkClaimConditions(addr: String, claimMode: Int, landAssetIdIn: String) = {
  let (landAssetId, duckId) = if (claimMode == claimModeWh) then (landAssetIdIn, getString(keyStakedDuckByOwner(addr)).valueOrElse("")) else {
    let duckAssetId = getString(keyStakedDuckByOwner(addr)).valueOrErrorMessage("You don't have a duck staked")
    let curLocation = getString(keyDuckLocation(duckAssetId)).valueOrElse(DEFAULTLOCATION)
    let loc = curLocation.value().split("_")
    if (loc[locIdxType] != "L") then throw("Duck location type is " + loc[locIdxType] + ", but should be L") else
    (loc[locIdxId], duckAssetId)
  }
  let asset = assetInfo(landAssetId.fromBase58String()).value()
  let timeKey = keyStakedTimeByAssetId(landAssetId)
  let savedTime = getInteger(timeKey).valueOrErrorMessage("Land " + asset.name + " is not staked")
  let owner = getString(keyLandAssetIdToOwner(landAssetId)).valueOrErrorMessage("NFT " + asset.name + " is orphaned")
  if (owner != addr) then throw(LANDPREFIX + " is not yours") else
  let d = asset.description.split("_") # ["445", "S", "BFBBFBDFBBEDDBDFEEBDBDBFF", "Africa"]
  (duckId, landAssetId, d, savedTime)
}

func claimResInternal(addr: String, amount: Int, claimMode: Int, landAssetIdIn: String) = {
  if (amount < 0) then throw("Negative amount") else
  let c = checkClaimConditions(addr, claimMode, landAssetIdIn) # (duckAssetId, landAssetId, d, savedTime)
  let landSize = c._3[recLandSize]
  let terrainCounts = countTerrains(c._3[recTerrains]) # [0, 10, 0, 6, 3, 6]
  let deltaTime = finalTime() - c._4
  if (deltaTime < 0) then throw("Saved timestamp is in future, saved = " + c._4.toString() + ", final = " + finalTime().toString()) else
  let pieces = numPiecesBySize(landSize)
  let dailyProductionByPiece = applyBonuses(c._2, pieces)
  let availRes = fraction(deltaTime, dailyProductionByPiece * pieces, DAYMILLIS)
  if (availRes < amount) then throw("Not enough resources, available = " + availRes.toString() + ", requested = " + amount.toString()) else
  let newDeltaTime = fraction(availRes - amount, DAYMILLIS, dailyProductionByPiece * pieces)
  let newTimestamp = finalTime() - newDeltaTime
  let landIndex = pieces / SSIZE
  let resToClaim = virtClaim(terrainCounts, deltaTime - newDeltaTime, landIndex, dailyProductionByPiece) # (List[Int], Int) - resList and its sum
  let whKey = keyWarehouseByLand(c._2)
  let infraLevel = getInteger(keyInfraLevelByAssetId(c._2)).valueOrElse(0)
  let currentWh = getWarehouse(whKey, landIndex, infraLevel)
  let loft = currentWh[whIdxLOFT].split("_")
  let whSpaceLeft = loft[volFree].parseIntValue()
  if (claimMode == claimModeWh && amount > whSpaceLeft) then throw("Only " + whSpaceLeft.toString() + " space left in warehouse") else

  let bpKey = keyBackpackByDuck(c._1)
  let currentPack = getBackpack(bpKey)
  let currentPackRes = currentPack[bpIdxRes].split("_") # resources already in backpack
  let currentWhRes = currentWh[whIdxRes].split("_") # resources already in warehouse
  let (whRes, bpRes, loftO, loftF) = if (claimMode == claimModeWh) then
    (addRes(currentWhRes, terrainCounts, deltaTime - newDeltaTime, landIndex, dailyProductionByPiece), currentPack[bpIdxRes], loft[volOccupied].parseIntValue() + resToClaim._2, loft[volFree].parseIntValue() - resToClaim._2)
  else if (claimMode == claimModeDuck) then
    (currentWh[whIdxRes], addRes(currentPackRes, terrainCounts, deltaTime - newDeltaTime, landIndex, dailyProductionByPiece), loft[volOccupied].parseIntValue(), loft[volFree].parseIntValue())
  else { # claimModeWhThenDuck - distribute resToClaim by warehouse and backpack
    let distr = distributeRes(currentWhRes, currentPackRes, resToClaim, whSpaceLeft)
    let whAm = min([loft[volFree].parseIntValue(), resToClaim._2])
    (distr._1, distr._2, loft[volOccupied].parseIntValue() + whAm, loft[volFree].parseIntValue() - whAm)
  }
  ([IntegerEntry(keyStakedTimeByAssetId(c._2), newTimestamp),
    IntegerEntry(keyStakedTimeByTypeAssetIdAndOwner(LANDPREFIX, c._2, addr), newTimestamp)], 
    bpKey, # StringEntry(bpKey, newPack) - should be saved by calling code
    [currentPack[bpIdxLevel], bpRes, currentPack[bpIdxMat], currentPack[bpIdxProd]],
    whKey, # StringEntry(whKey, newWarehouse) - should be saved by calling code
    [currentWh[whIdxLevels], whRes, currentWh[whIdxMat], currentWh[whIdxProd], makeString([loft[volLocked], toString(loftO), toString(loftF), loft[volTotal]], "_")]
  ) # (timeActions, bpKey, backpackList, whKey, warehouseList)
}

func claimAll(addr: String, landAssetId: String, pieces: Int, claimMode: Int) = {
  let timeKey = keyStakedTimeByAssetId(landAssetId)
  let savedTime = getInteger(timeKey).value()
  let availRes = fraction(finalTime() - savedTime, applyBonuses(landAssetId, pieces), DAYMILLIS) * pieces
  claimResInternal(addr, availRes, claimMode, landAssetId) # (timeActions, bpKey, backpackList, whKey, warehouseList)
}

func updateStatsInternal(lvlKey: String, xpKey: String, pointsKey: String, deltaXP: Int) = {
  let xp = getInteger(xpKey).valueOrElse(0)
  let newXP = xp + deltaXP
  let lvlPoints = levelUp(getInteger(lvlKey).valueOrElse(0), newXP)
  ([
    IntegerEntry(lvlKey, lvlPoints[0]),
    IntegerEntry(xpKey, newXP),
    IntegerEntry(pointsKey, getInteger(pointsKey).valueOrElse(0) + lvlPoints[1])
  ], newXP)
}

func updateDuckStatsInternal(duckAssetId: String, deltaXP: Int) = {
  let asset = assetInfo(duckAssetId.fromBase58String()).value()
  let addr = getString(keyDuckIdToOwner(duckAssetId)).valueOrErrorMessage("NFT " + asset.name + " is orphaned")
  if (KS_ALLOW_ROBO_DUCKS && asset.issuer == this && asset.name.contains(ROBO_PREFIX))
    then updateStatsInternal(keyUserLevel(addr), keyUserXP(addr), keyUserFreePoints(addr), deltaXP)
    else updateStatsInternal(keyDuckLevel(duckAssetId), keyDuckXP(duckAssetId), keyDuckFreePoints(duckAssetId), deltaXP)
}

func updateAccStatsInternal(addr: String, deltaXP: Int) = {
  updateStatsInternal(keyUserLevel(addr), keyUserXP(addr), keyUserFreePoints(addr), deltaXP)
}

func activateOnboardArt(addr: String) = {
  let duckAssetId = getString(keyStakedDuckByOwner(addr)).valueOrErrorMessage("You don't have a duck staked")
  let refByKey = keyAddressRefBy(addr)
  let refBy = getString(refByKey)
  if (!refBy.isDefined()) then throw("You are not eligible for ONBOARD artifact") else
  let artKey = keyOnboardArtDuckActivatedBy(addr)
  let artDuck = getString(artKey)
  if (artDuck.isDefined()) then throw("You already used your ONBOARD artifact on duck " + artDuck.value()) else
  let duckActivatorKey = keyOnboardArtActivatedOnDuck(duckAssetId)
  let duckActivator = getString(duckActivatorKey)
  if (duckActivator.isDefined()) then throw("The duck " + duckAssetId + " already got points from ONBOARD artifact from user " + duckActivator.value()) else
  [ StringEntry(artKey, duckAssetId),
    StringEntry(duckActivatorKey, addr)]
  ++ updateDuckStatsInternal(duckAssetId, xpOnboard)._1
}

func activatePresaleArt(addr: String, landAssetIdIn: String) = {
  let c = checkClaimConditions(addr, claimModeWhThenDuck, landAssetIdIn) # (duckAssetId, landAssetId, d, savedTime)
  let landAssetId = c._2
  let pieces = numPiecesBySize(c._3[recLandSize])
  let activationKey = keyLandArtStatusByTypeAndAssetId(ARTPRESALE, landAssetId)
  if (getInteger(activationKey).valueOrElse(0) > 0) then throw("Presale artifact is already activated") else
  if (c._3[recLandNum].parseIntValue() > PRESALENUMLANDS) then throw(LANDPREFIX + " " + landAssetId + " is not eligible for presale artifact") else
  let claimResult = claimAll(addr, landAssetId, pieces, claimModeWhThenDuck) # (timeActions, bpKey, backpackList, whKey, warehouseList)
  
  claimResult._1 # timeActions from claimAll
  :+ IntegerEntry(activationKey, pieces)
  :+ StringEntry(claimResult._2, makeString(claimResult._3, ":")) # bpKey, backpackList
  :+ StringEntry(claimResult._4, makeString(claimResult._5, ":")) # whKey, warehouseList
}

func checkTournament(duckAssetId: String) = {
  let lastId = tournamentContract.getInteger(lastTourIdKey).valueOrElse(0)
  let curLocation = getString(keyDuckLocation(duckAssetId)).valueOrElse(DEFAULTLOCATION).split("_")
  # location = continent_type_id; For tournaments: tId_T_distance
  let now = lastBlock.timestamp
  let tData = tournamentContract.getTourData(lastId)
  let static = tData[idxStatic]
  let dynamic = tData[idxDynamic]
  if (curLocation[locIdxType] != "T") then false else {
    if (curLocation[locIdxContinent].parseIntValue() == lastId &&
      dynamic[tDynamicStatus] == "INPROGRESS" && 
      now < static[tStaticEnd].parseIntValue()) then throw("Your duck is taking part in the tournament") else
    this.invoke("exitTournamentInternal", [duckAssetId], []).asBoolean() # silently exit outdated tournament
  }
}

func prolog(i: Invocation) = {
  if (i.originCaller != restContract && getBoolean(keyBlocked()).valueOrElse(false)) then throw("Contracts are under maintenance") else
  [StringEntry(keyLastTxIdByUser(i.originCaller.toString()), i.transactionId.toBase58String())]
}

func unstakeLandInternal(addr: String, landAssetId: String) = {
  let whKey = keyWarehouseByLand(landAssetId)
  let landInfo = assetInfo(landAssetId.fromBase58String()).value().description.split("_")
  let landSize = landInfo[recLandSize]
  let pieces = numPiecesBySize(landSize)
  let infraLevel = getInteger(keyInfraLevelByAssetId(landAssetId)).valueOrElse(0)
  let landIndex = pieces / SSIZE
  let terrainCounts = countTerrains(landInfo[recTerrains]) # [0, 10, 0, 6, 3, 6]
  let currentWh = getWarehouse(whKey, landIndex, infraLevel)
  let currentWhRes = currentWh[whIdxRes].split("_") # resources already in warehouse

  let timeKey = keyStakedTimeByAssetId(landAssetId)
  let savedTime = getIntegerValue(timeKey)
  let deltaTime = finalTime() - savedTime
  if (deltaTime < 0) then throw("Saved timestamp is in future, saved = " + savedTime.toString() + ", final = " + finalTime().toString()) else
  let dailyProductionByPiece = applyBonuses(landAssetId, pieces)

  let resAfterClaim = virtClaimAddRes(currentWhRes, terrainCounts, deltaTime, landIndex, dailyProductionByPiece) # (List[Int], Int) - resList and its sum

  let artPieces = getInteger(keyLandArtStatusByTypeAndAssetId(ARTPRESALE, landAssetId)).valueOrElse(0)
  let acresFromPieces = pieces * MULT8 + (pieces * infraLevel + artPieces) * MULT8 / 5
  
  let acresFromRes = fraction(resAfterClaim._2, RESOURCEPRICEMIN, MULT8) * USDT2ACRES_MULTIPLIER

  func sumMat(acc: Int, item: String) = acc + item.parseIntValue()
  let whMat = FOLD<6>(currentWh[whIdxMat].split("_"), 0, sumMat)
  let acresFromMat = fraction(whMat, 2 * RESOURCEPRICEMIN, MULT8) * USDT2ACRES_MULTIPLIER

  let prods = if (currentWh[whIdxProd] == "") then [] else currentWh[whIdxProd].split_4C("_")
  func sumProd(acc: (Int, Int), item: String) = {
    let j = acc._2
    let recipeCoeff = productionMatrix[j].split("_")[rIdxCoeff].parseIntValue()
    (acc._1 + item.parseIntValue() * recipeCoeff * MULT6, j + 1)
  }
  let whProd = FOLD<24>(prods, (0, 0), sumProd)
  let acresFromProd = fraction(whProd._1, 2 * RESOURCEPRICEMIN, MULT8) * USDT2ACRES_MULTIPLIER
  (acresFromPieces, acresFromRes, acresFromMat, acresFromProd)
}

# 01:3,02:3;01:3,_01:3,02:3;01:3,_;_;_;_;
# equipment.split("_") => list of 6 segments ['backpack', 'back', 'belt', 'hands', 'head', 'body']
# segment.split(";") => list of [mainSlots, auxSlots]
# {mainSlots|auxSlots}.split(",") => [slot0, slot1, ...]
# slot.split(":") => [productIdx, count]
func unstakeDuckInternal(addr: String, duckAssetId: String) = {
  let eqKey = keyDuckEquipment(duckAssetId)
  let currentSegs = getString(eqKey).valueOrElse(",;,_,;,_,;,_,;,_,;,_,;,").split("_")
  let bpKey = keyBackpackByDuck(duckAssetId)
  let currentPack = getBackpack(bpKey) # list of 4 strings: [level, resListStr, matListStr, prodListStr]
  let tempProdB = dressB(currentSegs, prodStrToBytes(currentPack[bpIdxProd]), true, []) # take off
  let newProdStr = bytesToProdStr(tempProdB) # can produce ""?

  func sumResMat(acc: Int, item: String) = acc + item.parseIntValue()

  let bpRes = FOLD<6>(currentPack[bpIdxRes].split("_"), 0, sumResMat)
  let acresFromRes = fraction(bpRes, RESOURCEPRICEMIN, MULT8) * USDT2ACRES_MULTIPLIER
  
  let bpMat = FOLD<6>(currentPack[bpIdxMat].split("_"), 0, sumResMat)
  let acresFromMat = fraction(bpMat, 2 * RESOURCEPRICEMIN, MULT8) * USDT2ACRES_MULTIPLIER

  let prods = if (newProdStr == "") then [] else newProdStr.split_4C("_")
  func sumProd(acc: (Int, Int), item: String) = {
    let j = acc._2
    let recipeCoeff = productionMatrix[j].split("_")[rIdxCoeff].parseIntValue()
    (acc._1 + item.parseIntValue() * recipeCoeff * MULT6, j + 1)
  }
  let bpProd = FOLD<24>(prods, (0, 0), sumProd)
  let acresFromProd = fraction(bpProd._1, 2 * RESOURCEPRICEMIN, MULT8) * USDT2ACRES_MULTIPLIER
  (acresFromRes, acresFromMat, acresFromProd)
}

@Callable(i)
func constructorV1(restAddr: String) = {
  if (i.caller != this) then throw("Permission denied") else
  [StringEntry(keyRestAddress(), restAddr)]
}

@Callable(i)
func saveInteger(key: String, amount: Int) = {
  if (i.caller != this) then throw("saveInteger is not public method") else
  [IntegerEntry(key, amount)]
}

@Callable(i)
func setBlocked(isBlocked: Boolean) = {
  if (i.caller != this) then throw("permission denied") else
  [BooleanEntry(keyBlocked(), isBlocked)]
}

@Callable(i)
func stakeLand() = {
  let prologActions = prolog(i)
  if (i.payments.size() != 1) then throw("Exactly one payment required") else
  let pmt = i.payments[0].value()
  let assetId = pmt.assetId.value()
  let address = i.caller.toString()
  if (pmt.amount != 1) then throw("NFT " + LANDPREFIX + " token should be attached as payment") else
  let asset = assetInfo(assetId).value()
  if (asset.issuer != this) then throw("Unknown issuer of token") else
  if (!asset.name.contains(LANDPREFIX)) then throw("Only NFT " + LANDPREFIX + " tokens are accepted") else
  let landNumSize = asset.name.drop(4)
  let landNum = if (landNumSize.contains("XXL")) then landNumSize.dropRight(3)
    else if (landNumSize.contains("XL")) then landNumSize.dropRight(2)
    else landNumSize.dropRight(1) # S, M, L
  if (!landNum.parseInt().isDefined()) then throw("Cannot parse land number from " + asset.name) else
  let landAssetId = assetId.toBase58String()
  let timeKey = keyStakedTimeByAssetId(landAssetId)
  if (isDefined(getInteger(timeKey))) then throw("NFT " + asset.name + " is already staked") else
  let d = asset.description.split("_") # ["445", "S", "BFBBFBDFBBEDDBDFEEBDBDBFF", "Africa"]
  let terrainCounts = countTerrains(d[recTerrains]) # [0, 10, 0, 6, 3, 6]
  let pieces = numPiecesBySize(d[recLandSize])
  let landIndex = pieces / SSIZE
  let props = updateProportions(terrainCounts, landIndex, 1)
  let resByContKey = keyResTypesByContinent(d[recContinent])
  let contProps = getString(resByContKey).valueOrElse("0_0_0_0_0_0").split("_")
  let updatedContProps = updateProportionsInternal(contProps, terrainCounts, landIndex, 1).makeString("_")
  let landsKey = keyStakedLandsByOwner(address)
  let landsStr = getString(landsKey)
  let lands = if (landsStr.isDefined()) then split_51C(landsStr.value(), "_") else []
  if (lands.containsElement(landAssetId)) then throw("Your staked lands already contain " + landAssetId) else
  if (lands.size() >= MAX_LANDS_STAKED_BY_USER) then throw("Your already staked max (" + MAX_LANDS_STAKED_BY_USER.toString() + ") lands") else
  let infraLevel = getInteger(keyInfraLevelByAssetId(landAssetId)).valueOrElse(0)
  let piecesKey = keyStakedPiecesByOwner(address)
  let oldPieces = getInteger(piecesKey).valueOrElse(0)
  let wlgResult = wlgContract.invoke("onStakeUnstakeLand", [address], [])

  ([IntegerEntry(timeKey, lastBlock.timestamp),
    IntegerEntry(keyStakedTimeByTypeAssetIdAndOwner(LANDPREFIX, landAssetId, address), lastBlock.timestamp),
    StringEntry(landsKey, makeString_11C(lands :+ landAssetId, "_")),
    IntegerEntry(piecesKey, oldPieces + pieces),
    StringEntry(keyLandAssetIdToOwner(landAssetId), address),
    StringEntry(keyLandNumToOwner(landNum), address),
    IntegerEntry(keyInfraLevelByAssetIdAndOwner(landAssetId, address), infraLevel),
    StringEntry(keyResProportions(), props), 
    StringEntry(resByContKey, updatedContProps)] ++ prologActions, wlgResult)
}

@Callable(i)
func unstakeLand(landAssetIdIn: String) = {
  let prologActions = prolog(i)
  if (i.payments.size() != 0) then throw("No payments required") else
  let addr = i.caller.toString()
  let c = checkClaimConditions(addr, claimModeDuck, landAssetIdIn) # (duckId, landAssetId, d, savedTime)
  let landAssetId = c._2
  let d = c._3
  let landsKey = keyStakedLandsByOwner(addr)
  let terrainCounts = countTerrains(d[recTerrains]) # [0, 10, 0, 6, 3, 6]
  let pieces = numPiecesBySize(d[recLandSize])
  let landIndex = pieces / SSIZE
  let props = updateProportions(terrainCounts, landIndex, -1)
  let resByContKey = keyResTypesByContinent(d[recContinent])
  let contProps = getString(resByContKey).valueOrElse("0_0_0_0_0_0").split("_")
  let updatedContProps = updateProportionsInternal(contProps, terrainCounts, landIndex, -1).makeString("_")
  let claimResult = claimAll(addr, landAssetId, pieces, claimModeDuck) # (actions: [keyStakedTimeByAssetId, keyStakedTimeByTypeAssetIdAndOwner], bpKey, backpackList)
  let lands = split_51C(getString(landsKey).valueOrElse(""), "_")
  let idx = lands.indexOf(landAssetId)
  if (!idx.isDefined()) then throw("Your staked lands don't contain " + landAssetId) else
  # check if gWL are taking part in votings
  let now = lastBlock.timestamp
  let govReleaseTime = govContract.getInteger(keyUserGwlReleaseTime(addr)).valueOrElse(0)
  if (now <= govReleaseTime) then throw("Your gWL are taking part in voting, cannot unstake until " + govReleaseTime.toString()) else
  let arbReleaseTime = wlgContract.getInteger(keyLastArbTimeByUser(addr)).valueOrElse(0) + arbitrageDelay
  if (now < arbReleaseTime) then throw("Your staked lands took part in arbitrage, cannot unstake until " + arbReleaseTime.toString()) else
  let piecesKey = keyStakedPiecesByOwner(addr)
  let stakedPieces = getInteger(piecesKey).valueOrElse(0)
  let newPieces = if (stakedPieces < pieces) then 0 else stakedPieces - pieces
  let wlgResult = wlgContract.invoke("onStakeUnstakeLand", [addr], [])

  ([ScriptTransfer(i.caller, 1, landAssetId.fromBase58String()),
    DeleteEntry(keyStakedTimeByAssetId(landAssetId)),
    DeleteEntry(keyStakedTimeByTypeAssetIdAndOwner(LANDPREFIX, landAssetId, addr)),
    StringEntry(keyResProportions(), props),
    StringEntry(resByContKey, updatedContProps),
    StringEntry(claimResult._2, makeString(claimResult._3, ":")),
    if (lands.size() > 1) then StringEntry(landsKey, makeString_11C(lands.removeByIndex(idx.value()), "_")) else DeleteEntry(landsKey),
    IntegerEntry(piecesKey, newPieces)] ++ prologActions, wlgResult)
}

@Callable(i)
func unstakeLandCallback(landAssetId: String, addr: String) = {
  if (i.caller.toString() != acres2AddressStr) then throw("Permission denied") else
  let unstakeResult = unstakeLandInternal(addr, landAssetId)

  let wlgResult = wlgContract.invoke("onStakeUnstakeLand", [addr], [])

  ([Burn(landAssetId.fromBase58String(), 1),
    DeleteEntry(keyStakedTimeByAssetId(landAssetId)),
    DeleteEntry(keyStakedTimeByTypeAssetIdAndOwner(LANDPREFIX, landAssetId, addr))
  ], (unstakeResult._1, unstakeResult._2, unstakeResult._3, unstakeResult._4, wlgResult))
}

@Callable(i)
func unstakeLandREADONLY(landAssetId: String, addr: String) = {
  let unstakeResult = unstakeLandInternal(addr, landAssetId)

  # (acresFromPieces, acresFromRes, acresFromMat, acresFromProd)
  ([], unstakeResult)
}

@Callable(i)
func unstakeLandsFinalizeCallback(addr: String) = {
  if (i.caller.toString() != acres2AddressStr) then throw("Permission denied") else
  ([DeleteEntry(keyStakedLandsByOwner(addr)),
    DeleteEntry(keyStakedPiecesByOwner(addr))
  ], 0)
}

# for late users that forgot to stake their NFT lands before conversion to 2.0 version
@Callable(i)
func convertUnstakedLands() = {
  if (i.payments.size() != 1) then throw("Exactly one payment required") else
  let pmt = i.payments[0].value()
  let assetId = pmt.assetId.value()
  let address = i.caller.toString()
  if (pmt.amount != 1) then throw("NFT " + LANDPREFIX + " token should be attached as payment") else
  let asset = assetInfo(assetId).value()
  if (asset.issuer != this) then throw("Unknown issuer of token") else
  if (!asset.name.contains(LANDPREFIX)) then throw("Only NFT " + LANDPREFIX + " tokens are accepted") else
  let landAssetId = assetId.toBase58String()
  let d = asset.description.split("_") # ["445", "S", "BFBBFBDFBBEDDBDFEEBDBDBFF", "Africa"]
  let pieces = numPiecesBySize(d[recLandSize])

  let infraLevel = getInteger(keyInfraLevelByAssetId(landAssetId)).valueOrElse(0)
  let artPieces = getInteger(keyLandArtStatusByTypeAndAssetId(ARTPRESALE, landAssetId)).valueOrElse(0)
  let acresAmount = pieces * MULT8 + (pieces * infraLevel + artPieces) * MULT8 / 5
  strict req = acresContract.invoke("requestAcresCallback", [acresAmount], [])
  strict callb = acres2AddressStr.addressFromStringValue().invoke("stakeAcresCallback", [address], [AttachedPayment(acresAssetId, acresAmount)])

  ([Burn(landAssetId.fromBase58String(), 1)], 0)
}

@Callable(i)
func stakeDuck() = {
  let prologActions = prolog(i)
  if (i.payments.size() != 1) then throw("Exactly one payment required") else
  let pmt = i.payments[0].value()
  let assetId = pmt.assetId.value()
  let address = i.caller.toString()
  if (pmt.amount != 1) then throw("NFT " + DUCKPREFIX + " token should be attached as payment") else
  let asset = assetInfo(assetId).value()
  let isRobo = KS_ALLOW_ROBO_DUCKS && asset.issuer == this && asset.name.contains(ROBO_PREFIX)
  if (asset.issuer != incubatorAddr && asset.issuer != breederAddr 
    && !isRobo) then throw("Unknown issuer of " + DUCKPREFIX + " or " + ROBO_PREFIX + " token") else
  if (!asset.name.contains(DUCKPREFIX) && !isRobo) then throw("Only NFT " + DUCKPREFIX + " or " + ROBO_PREFIX + " tokens are accepted") else
  let assetIdStr = assetId.toBase58String()
  let timeKey = keyStakedTimeByAssetId(assetIdStr)
  if (isDefined(getInteger(timeKey))) then throw("NFT " + asset.name + " is already staked") else
  if (isDefined(getString(keyStakedDuckByOwner(address)))) then throw("You already staked one duck: " + asset.name) else
  let locKey = keyDuckLocation(assetIdStr)
  let location = getString(locKey)
  let bpKey = keyBackpackByDuck(assetIdStr)
  let backpack = getString(bpKey)
  let keyHealth = keyDuckHealth(assetIdStr)
  let maxHP = maxHealth(getInteger(keyDuckLevel(assetIdStr)).valueOrElse(0))
  let curHealth = getInteger(keyHealth).valueOrElse(maxHP)

  [IntegerEntry(timeKey, lastBlock.timestamp),
    IntegerEntry(keyStakedTimeByTypeAssetIdAndOwner(DUCKPREFIX, assetId.toBase58String(), address), lastBlock.timestamp),
    StringEntry(keyDuckIdToOwner(assetIdStr), address),
    StringEntry(keyStakedDuckByOwner(address), assetIdStr)]
    ++ if (location.isDefined()) then [] else [StringEntry(locKey, DEFAULTLOCATION)]
    ++ if (backpack.isDefined()) then [] else [StringEntry(bpKey, "0:0_0_0_0_0_0:0_0_0_0_0_0:")]
    :+ IntegerEntry(keyHealth, curHealth)
    ++ prologActions
}

@Callable(i)
func unstakeDuck(assetIdStr: String) = {
  let prologActions = prolog(i)
  if (i.payments.size() != 0) then throw("No payments required") else
  let assetId = assetIdStr.fromBase58String()
  let address = i.caller.toString()
  let asset = assetInfo(assetId).value()
  let timeKey = keyStakedTimeByAssetId(assetIdStr)
  if (!isDefined(getInteger(timeKey))) then throw("NFT " + asset.name + " is not staked") else
  if (!isDefined(getString(keyStakedDuckByOwner(address)))) then throw("The duck " + asset.name + " is not staked") else
  let owner = getString(keyDuckIdToOwner(assetIdStr)).valueOrErrorMessage("NFT " + asset.name + " is orphaned")
  if (owner != address) then throw("Staked NFT is not yours") else
  if (checkTournament(assetIdStr)) then throw("unstakeDuck_checkTournament") else
  let keyHealth = keyDuckHealth(assetIdStr)
  let maxHP = maxHealth(getInteger(keyDuckLevel(assetIdStr)).valueOrElse(0))
  let health = getInteger(keyHealth).valueOrElse(maxHP)
  if (health < maxHP) then throw("Please heal your duck to " + maxHP.toString() + "hp before unstaking") else 

  [ScriptTransfer(i.caller, 1, assetId),
    DeleteEntry(timeKey),
    DeleteEntry(keyHealth),
    DeleteEntry(keyDuckLocation(assetIdStr)),
    DeleteEntry(keyDuckIdToOwner(assetIdStr)),
    DeleteEntry(keyStakedTimeByTypeAssetIdAndOwner(DUCKPREFIX, assetIdStr, address)),
    DeleteEntry(keyStakedDuckByOwner(address))] ++ prologActions
}

@Callable(i)
func unstakeDuckCallback(duckAssetId: String, addr: String) = {
  if (i.caller.toString() != acres2AddressStr) then throw("Permission denied") else
  let unstakeResult = unstakeDuckInternal(addr, duckAssetId)

  ([ScriptTransfer(addr.addressFromStringValue(), 1, duckAssetId.fromBase58String()), 
    DeleteEntry(keyStakedTimeByAssetId(duckAssetId)),
    DeleteEntry(keyDuckIdToOwner(duckAssetId)),
    DeleteEntry(keyStakedTimeByTypeAssetIdAndOwner(DUCKPREFIX, duckAssetId, addr)),
    DeleteEntry(keyStakedDuckByOwner(addr))], unstakeResult)
}

@Callable(i)
func unstakeDuckREADONLY(duckAssetId: String, addr: String) = {
  let unstakeResult = unstakeDuckInternal(addr, duckAssetId)
  # (acresFromRes, acresFromMat, acresFromProd)
  ([], unstakeResult)
}

# calc res produced by staked land in a time interval since last update
# move choosen amount of res to duck's backpack
# backPack data: ${backPackUpgradeLevel}:${Oil}_${Ore}_${Wood}_${Sand}_${Clay}_${Organic}:{materials}:{products}
@Callable(i)
func claimRes(amount: Int, landAssetIdStr: String) = {
  let prologActions = prolog(i)
  if (i.payments.size() != 0) then throw("No payments required") else
  let addr = i.originCaller.toString()
  let result = claimResInternal(addr, amount, claimModeDuck, landAssetIdStr) # (actions, bpKey, backpackList, whKey, warehouseList)
  let duckAssetId = getString(keyStakedDuckByOwner(addr)).valueOrErrorMessage("You don't have a duck staked")

  (result._1
  ++ updateDuckStatsInternal(duckAssetId, fraction(xpClaim, amount, MULT8))._1
  :+ StringEntry(result._2, makeString(result._3, ":")) # bpKey, backpackList
  :+ StringEntry(result._4, makeString(result._5, ":")) # whKey, warehouseList
  ++ prologActions,
    result._3[bpIdxRes])
}

# calc res produced by staked land in a time interval since last update
# move choosen amount of res to land's warehouse
# warehouse data: ${warehouseVolume}:${Oil}_${Ore}_${Wood}_${Sand}_${Clay}_${Organic}:{materials}:{products}
@Callable(i)
func claimResToWH(amount: Int, landAssetIdStr: String) = {
  let prologActions = prolog(i)
  if (i.payments.size() != 0) then throw("No payments required") else
  let addr = i.originCaller.toString()
  let result = claimResInternal(addr, amount, claimModeWh, landAssetIdStr) # (actions, bpKey, backpackList, whKey, warehouseList)
  (result._1
  ++ updateAccStatsInternal(addr, fraction(xpClaim, amount, MULT8))._1
  :+ StringEntry(result._2, makeString(result._3, ":")) # bpKey, backpackList
  :+ StringEntry(result._4, makeString(result._5, ":")) # whKey, warehouseList
  ++ prologActions,
    result._5[whIdxRes])
}

# callback for economy contract
@Callable(i)
func updateBackpack(duckAssetId: String, newPack: String) = {
  if (i.caller != economyContract) then throw("permission denied") else

  ([StringEntry(keyBackpackByDuck(duckAssetId), newPack)], newPack)
}

# callback for economics contract
@Callable(i)
func saveWarehouse(whStr: String, landAssetId: String) = {
  if (i.caller != economyContract) then throw("Access denied") else
  let whKey = keyWarehouseByLand(landAssetId)
  let wh = split_4C(whStr, ":") # list of 5 strings: [volPrefix, resListStr, matListStr, prodListStr, LOFT]
  if (wh.size() != 5) then throw("warehouse string should contain 4 ':' separators") else
  let loftL = wh[whIdxLOFT].split("_")[volLocked]
  let loftO = getWarehouseOccupiedVol(wh)
  let loftT = getWarehouseTotalVolume(wh[whIdxLevels])
  let loftF = loftT - loftL.parseIntValue() - loftO
  if (loftF < 0) then throw("Operation leads to negative free warehouse space") else
  let newWhStr = makeString_2C([wh[whIdxLevels], wh[whIdxRes], wh[whIdxMat], wh[whIdxProd], 
    makeString([loftL, loftO.toString(), loftF.toString(), loftT.toString()], "_")], ":")
  ([StringEntry(whKey, newWhStr)], newWhStr)
}

@Callable(i)
func splitByGlobalWeightsREADONLY(amount: Int) = {
  ([], getNeededMaterials(amount)) # returns List of 6 materials according to current global res proportions
}

# terrains: "BFBBFBDFBBEDDBDFEEBDBDBFF"
@Callable(i)
func splitByGlobalAndLocalWeightsREADONLY(matAmount: Int, resAmount: Int, terrains: String) = {
  let terrainCounts = countTerrains(terrains) # [0, 10, 0, 6, 3, 6]
  ([], 
    (getNeededMaterials(matAmount), # returns List of 6 materials according to current global res proportions
    distributeByWeights(resAmount, terrainCounts)) # returns amounts[] distributed according to terrainCounts
  )
}

@Callable(i)
func getBackpackREADONLY(duckAssetId: String) = {
  ([], getBackpack(keyBackpackByDuck(duckAssetId)).makeString(":"))
}

@Callable(i)
func getWarehouseREADONLY(landAssetId: String) = {
  let asset = assetInfo(landAssetId.fromBase58String()).value()
  let landIndex = numPiecesBySize(asset.description.split("_")[recLandSize]) / SSIZE
  let infraLevel = getInteger(keyInfraLevelByAssetId(landAssetId)).valueOrElse(0)
  ([], makeString_2C(getWarehouse(keyWarehouseByLand(landAssetId), landIndex, infraLevel), ":"))
}

# callback for secondary contracts
@Callable(i)
func saveLastTx() = {
  if (!containsElement([wlgContract, economyContract, tournamentContract, acresContract], i.caller)) then throw("Access denied") else
  (prolog(i), 42)
}

# callback for economics contract
@Callable(i)
func updateDuckStats(duckAssetId: String, deltaXP: Int) = {
  if (i.caller != economyContract) then throw("Access denied") else
  updateDuckStatsInternal(duckAssetId, deltaXP)
}

# callback for economics and acres contracts
@Callable(i)
func updateAccStats(addr: String, deltaXP: Int) = {
  if (!containsElement([wlgContract, economyContract, acresContract], i.caller)) then throw("Access denied") else
  updateAccStatsInternal(addr, deltaXP)
}
